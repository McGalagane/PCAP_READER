<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Traffic Visualization</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            max-height: 100vh;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            text-align: center;
        }
        .content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        .graph-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            border: 1px solid #ddd;
            background-color: #fff;
        }
        #graph {
            width: 100%;
            height: 100%;
        }
        .sidebar {
            width: 250px;
            background-color: #f9f9f9;
            padding: 15px;
            border-left: 1px solid #ddd;
            overflow-y: auto;
            transition: width 0.3s ease;
        }
        .sidebar.collapsed {
            width: 0;
            padding: 0;
            overflow: hidden;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #2c3e50;
            font-size: 16px;
        }
        input[type="range"], select, input[type="text"] {
            width: 100%;
            margin: 5px 0;
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        .footer {
            background-color: #f1f1f1;
            padding: 10px;
            text-align: center;
            font-size: 12px;
            border-top: 1px solid #ddd;
        }
        .node-info {
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            position: absolute;
            top: 10px;
            left: 10px;
            max-width: 300px;
            display: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .stat-box {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 15px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .stat-box h4 {
            margin-top: 0;
            margin-bottom: 5px;
            color: #2c3e50;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin: 2px;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #2980b9;
        }
        .legend {
            display: flex;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 10px;
            margin-bottom: 5px;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 5px;
            border-radius: 50%;
        }
        .protocol-link {
            stroke-width: 3;
            stroke-dasharray: 0;
            opacity: 0.8;
        }
        .selected-node {
            stroke: #ff6b6b;
            stroke-width: 3px;
        }
        .node-tooltip {
            position: absolute;
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 10;
            display: none;
        }
        .protocol-legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            margin-top: 15px;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 4px;
            border: 1px solid #ddd;
            z-index: 100;
            max-width: 300px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .protocol-legend h4 {
            margin-top: 0;
            margin-bottom: 10px;
        }
        .toggle-sidebar {
            position: absolute;
            top: 50%;
            right: 2px;
            transform: translateY(-50%);
            z-index: 1000;
            width: 20px;
            height: 60px;
            background-color: #2c3e50;
            border: none;
            border-radius: 4px 0 0 4px;
            color: white;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0;
            transition: right 0.3s ease;
        }
        .toggle-sidebar.sidebar-hidden {
            right: 0;
        }
        .toggle-sidebar:hover {
            background-color: #34495e;
        }
        .toggle-sidebar:focus {
            outline: none;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Network Traffic Visualization</h1>
        </div>
        <div class="content">
            <div class="graph-container">
                <div id="graph"></div>
                <div class="node-info" id="nodeInfo"></div>
                <div class="node-tooltip" id="nodeTooltip"></div>
                <div class="protocol-legend" id="protocolLegend" style="display: none;">
                    <h4>Protocol Legend</h4>
                    <div id="protocolItems"></div>
                </div>
                <button id="toggleSidebar" class="toggle-sidebar">
                    &lt;
                </button>
            </div>
            <div class="sidebar" id="sidebar">
                <div class="stat-box">
                    <h4>Network Statistics</h4>
                    <div id="stats">
                        <p>Total Packets: <span id="totalPackets">0</span></p>
                        <p>Unique IP Addresses: <span id="uniqueIPs">0</span></p>
                        <p>Most Active Source: <span id="activeSource">-</span></p>
                        <p>Most Active Destination: <span id="activeDest">-</span></p>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Layout Controls</h3>
                    <label for="linkDistance">Link Distance:</label>
                    <input type="range" id="linkDistance" min="10" max="300" value="150">
                    
                    <label for="nodeCharge">Node Attraction:</label>
                    <input type="range" id="nodeCharge" min="-1000" max="0" value="-300">
                    
                    <label for="nodeSize">Node Size:</label>
                    <input type="range" id="nodeSize" min="2" max="20" value="8">
                </div>
                
                <div class="control-group">
                    <h3>Filter</h3>
                    <label for="protocolFilter">Filter by Protocol:</label>
                    <select id="protocolFilter" style="width: 100%; margin-bottom: 5px;">
                        <option value="">-- Select Protocol --</option>
                    </select>
                    
                    <label for="searchFilter">Search by IP:</label>
                    <input type="text" id="searchFilter" placeholder="Enter IP address" style="width: 100%; margin-bottom: 5px;">
                    <button id="applyFilter">Apply Filter</button>
                    <button id="resetFilter">Reset</button>
                </div>
                
                <div class="control-group">
                    <h3>Selected Node Information</h3>
                    <div id="selectedNodeInfo">
                        <p>Click on nodes to select them</p>
                        <p id="selectedCount">0 nodes selected</p>
                        <button id="clearSelection" disabled>Clear Selection</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Legend</h3>
                    <h4>Nodes</h4>
                    <div class="legendNode" id="legendNodeContainer"></div>
                    <h4>Links</h4>
                    <div class="legendLink" id="legendLinkContainer"></div>
                </div>
                
                <div class="control-group">
                    <h3>Actions</h3>
                    <button id="exportSVG">Export as SVG</button>
                </div>
            </div>
        </div>
        <div class="footer">
            Network Traffic Visualization Tool | Packet Data Analysis
        </div>
    </div>

    <script>
        const pcapData = {}

        // Process the data to extract unique IPs and calculate frequencies
        function processData(data) {
            const nodes = new Map();
            const links = [];
            const ipCounts = {};
            const protocolCounts = {};
            
            // Helper function to extract the base IP without port
            function extractBaseIP(fullIP) {
                return fullIP.split(':')[0];
            }
            
            // Count occurrences of each IP and protocol
            Object.values(data).forEach(packet => {
                const sourceIP = extractBaseIP(packet.Source);
                const destIP = extractBaseIP(packet.Destination);
                const protocol = packet.Protocol || "Unknown";
                ipCounts[sourceIP] = (ipCounts[sourceIP] || 0) + 1;
                ipCounts[destIP] = (ipCounts[destIP] || 0) + 1;
                
                protocolCounts[protocol] = (protocolCounts[protocol] || 0) + 1;
            });
            
            // Create nodes
            Object.keys(ipCounts).forEach(ip => {
                // Define node type: source or destination
                let type = "both";
                const isSource = Object.values(data).some(p => extractBaseIP(p.Source) === ip);
                const isDest = Object.values(data).some(p => extractBaseIP(p.Destination) === ip);
                const matchingPacket = Object.values(data).find(p =>
                    extractBaseIP(p.Source) === ip || extractBaseIP(p.Destination) === ip
                );
                let vendor = 'Unknown';
                
                if (isSource && !isDest) {
                    type = "source";
                    vendor = matchingPacket?.src_vendor || "Unknown";
                }
                else if (!isSource && isDest) {
                    type = "destination";
                    vendor = matchingPacket?.dst_vendor || "Unknown";
                }
                if (type === 'both') {
                    const sourcePackets = Object.values(data).filter(p => extractBaseIP(p.Source) === ip);
                    vendor = sourcePackets[0].src_vendor;
                }
                // Add node
                nodes.set(ip, {
                    id: ip,
                    count: ipCounts[ip],
                    type: type,
                    vendor: vendor
                });
            });
            
            // Create links with protocol information
            const linkMap = new Map();
            
            Object.values(data).forEach(packet => {
                const sourceIP = extractBaseIP(packet.Source);
                const destIP = extractBaseIP(packet.Destination);
                const protocol = packet.Protocol || "Unknown";
                const linkKey = `${sourceIP}-${destIP}-${protocol}`;
                
                if (!linkMap.has(linkKey)) {
                    linkMap.set(linkKey, {
                        source: sourceIP,
                        target: destIP,
                        protocol: protocol,
                        value: 1
                    });
                } else {
                    linkMap.get(linkKey).value++;
                }
            });
            
            links.push(...linkMap.values());

            
            // Find most active IPs
            let maxCount = 0;
            let mostActiveSource = null;
            let maxDestCount = 0;
            let mostActiveDest = null;
            
            nodes.forEach((node, ip) => {
                if (node.type === "source" || node.type === "both") {
                    if (node.count > maxCount) {
                        maxCount = node.count;
                        mostActiveSource = ip;
                    }
                }
                if (node.type === "destination" || node.type === "both") {
                    if (node.count > maxDestCount) {
                        maxDestCount = node.count;
                        mostActiveDest = ip;
                    }
                }
            });
            
            return {
                nodes: Array.from(nodes.values()),
                links: links,
                stats: {
                    totalPackets: Object.keys(data).length,
                    uniqueIPs: nodes.size,
                    mostActiveSource: mostActiveSource,
                    mostActiveDest: mostActiveDest,
                    protocols: Object.keys(protocolCounts)
                }
            };
        }

        // Initialize the visualization
        function initializeGraph() {
            // Process data
            const processedData = processData(pcapData);
            let graphData = {
                nodes: [...processedData.nodes],
                links: [...processedData.links]
            };
            
            let simulation;
            let selectedNodes = [];
            
            // Update statistics
            document.getElementById('totalPackets').textContent = processedData.stats.totalPackets;
            document.getElementById('uniqueIPs').textContent = processedData.stats.uniqueIPs;
            document.getElementById('activeSource').textContent = processedData.stats.mostActiveSource || "-";
            document.getElementById('activeDest').textContent = processedData.stats.mostActiveDest || "-";
            
            // Populate protocol dropdown
            const protocolFilter = document.getElementById('protocolFilter');
            processedData.stats.protocols.forEach(protocol => {
                const option = document.createElement('option');
                option.value = protocol;
                option.textContent = protocol;
                protocolFilter.appendChild(option);
            });
            
            // Set initial control values
            let linkDistance = 150;
            let nodeCharge = -300;
            let baseNodeSize = 8;
            
            // Get the container dimensions
            const container = document.getElementById('graph');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // Create SVG element
            const svg = d3.select("#graph")
                .append("svg")
                .attr("width", width)
                .attr("height", height);
            
            // Better color scheme
            const nodeColors = {
                source: "#4CAF50",     // Green
                destination: "#2196F3", // Blue
                both: "#9C27B0"        // Purple
            };
            
            // Protocol colors
            const protocolColors = d3.scaleOrdinal()
                .domain(processedData.stats.protocols)
                .range(["#f44336", "#2196F3", "#FF9800", "#4CAF50", "#E91E63", "#009688", "#673AB7", "#FFC107"]);
            
            // Create a group for the graph elements
            const g = svg.append("g");
            
            // Add zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.1, 10])
                .on("zoom", (event) => {
                    g.attr("transform", event.transform);
                });
            
            svg.call(zoom);
            
            // Create a container for links
            const linkGroup = g.append("g").attr("class", "links");
            
            // Create links
            let link = linkGroup.selectAll("line")
                .data(graphData.links)
                .enter()
                .append("line")
                .attr("stroke", d => protocolColors(d.protocol))
                .attr("stroke-opacity", 0.6)
                .attr("stroke-width", d => Math.sqrt(d.value) + 1);
            
            // Create nodes
            let node = g.append("g")
                .attr("class", "nodes")
                .selectAll("circle")
                .data(graphData.nodes)
                .enter()
                .append("circle")
                .attr("r", d => calculateNodeSize(d))
                .attr("fill", d => getNodeColor(d))
                .attr("stroke", "#fff")
                .attr("stroke-width", 1.5)
                .attr("cursor", "pointer")
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));
            
            // Add text labels for larger nodes
            let labels = g.append("g")
                .selectAll("text")
                .data(graphData.nodes)
                .enter()
                .append("text")
                .text(d => d.count > 1 ? d.id : "")
                .attr("font-size", 10)
                .attr("dx", 12)
                .attr("dy", 4)
                .style("pointer-events", "none")
                .style("fill", "#333")
                .style("font-weight", "bold")
                .style("text-shadow", "0 0 3px white");
            
            // Initialize simulation
            simulation = d3.forceSimulation(graphData.nodes)
                .force("link", d3.forceLink(graphData.links).id(d => d.id).distance(linkDistance))
                .force("charge", d3.forceManyBody().strength(nodeCharge))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("x", d3.forceX(width / 2).strength(0.1))
                .force("y", d3.forceY(height / 2).strength(0.1))
                .on("tick", ticked);
            
            // Tooltip element for quick node info
            const tooltip = d3.select("#nodeTooltip");
            
            // Handle node information display
            node.on("mouseover", showNodeTooltip)
                .on("mouseout", hideNodeTooltip)
                .on("click", handleNodeClick);
            
            // Helper function to calculate node size based on frequency
            function calculateNodeSize(d) {
                return baseNodeSize + Math.sqrt(d.count);
            }
            
            // Helper function to determine node color based on type
            function getNodeColor(d) {
                return nodeColors[d.type];
            }
            
            // Update positions on each tick
            function ticked() {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);
                
                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);
                
                labels
                    .attr("x", d => d.x)
                    .attr("y", d => d.y);
            }
            
            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            
            // Show node tooltip on hover
            function showNodeTooltip(event, d) {
                const [x, y] = d3.pointer(event, svg.node());
                const outgoingLinks = graphData.links.filter(l => l.source.id === d.id)
                let outgoingSignals = 0
                outgoingLinks.forEach(link => {
                    outgoingSignals += link.value
                })

                const incomingLinks = graphData.links.filter(l => l.target.id === d.id)
                let incomingSignals = 0
                incomingLinks.forEach(link => {
                    incomingSignals += link.value
                })
                
                tooltip.style("left", (x + 10) + "px")
                      .style("top", (y + 10) + "px")
                      .style("display", "block")
                      .html(`<strong>${d.id}</strong> (${d.type})`);
                
                // Show detailed info in the sidebar
                const nodeInfo = document.getElementById('nodeInfo');
                nodeInfo.innerHTML = `
                    <strong>IP: ${d.id}</strong><br>
                    Type: ${d.type}<br>
                    Occurrences: ${incomingSignals + outgoingSignals}<br><br>
                    Outgoing connections: ${graphData.links.filter(l => l.source.id === d.id).length}<br>
                    outgoing signals: ${outgoingSignals}<br>
                    Incoming connections: ${graphData.links.filter(l => l.target.id === d.id).length}<br>
                    Incoming signals: ${incomingSignals}<br><br>
                    Vendor: ${d.vendor}
                `;
                nodeInfo.style.display = 'block';
            }
            
            function hideNodeTooltip() {
                tooltip.style("display", "none");
                document.getElementById('nodeInfo').style.display = 'none';
            }
            
            // Handle node click for selection
            function handleNodeClick(event, d) {
                // If node is already selected, remove it from selection
                const index = selectedNodes.findIndex(n => n.id === d.id);
                
                if (index > -1) {
                    selectedNodes.splice(index, 1);
                    d3.select(this).classed("selected-node", false);
                } else {
                    // If we already have 2 nodes selected, remove the first one
                    if (selectedNodes.length >= 2) {
                        const oldNode = selectedNodes.shift();
                        node.filter(n => n.id === oldNode.id).classed("selected-node", false);
                    }
                    
                    // Add the new node to selection
                    selectedNodes.push(d);
                    d3.select(this).classed("selected-node", true);
                }
                
                // Update selection count
                document.getElementById("selectedCount").textContent = `${selectedNodes.length} node(s) selected`;
                
                // Enable/disable clear button
                document.getElementById("clearSelection").disabled = selectedNodes.length === 0;
                
                // If we have exactly 2 nodes selected, show connections between them
                if (selectedNodes.length === 2) {
                    showConnectionsBetweenNodes(selectedNodes[0], selectedNodes[1]);
                } else {
                    // Otherwise reset to show all links
                    resetGraphVisibility();
                }
            }
            
            // Show connections between two selected nodes
            function showConnectionsBetweenNodes(node1, node2) {
                // Dim all nodes except the selected ones
                node.style("opacity", n => 
                    (n.id === node1.id || n.id === node2.id) ? 1 : 0.2);
                
                // Hide all labels except for selected nodes
                labels.style("opacity", n => 
                    (n.id === node1.id || n.id === node2.id) ? 1 : 0);
                
                // Find all links between the two nodes
                const nodeLinks = graphData.links.filter(l => 
                    (l.source.id === node1.id && l.target.id === node2.id) || 
                    (l.source.id === node2.id && l.target.id === node1.id)
                );

                // Hide all links except those between the selected nodes
                link.style("opacity", l => 
                    ((l.source.id === node1.id && l.target.id === node2.id) || 
                     (l.source.id === node2.id && l.target.id === node1.id)) ? 1 : 0.1);
                
                // Group links by protocol
                const protocolGroups = {};
                nodeLinks.forEach(l => {
                    if (!protocolGroups[l.protocol]) {
                        protocolGroups[l.protocol] = [];
                    }
                    protocolGroups[l.protocol].push(l);
                });
                
                // Update protocol legend
                updateProtocolLegend(protocolGroups);
                
                // Visually separate links by protocol (offset them slightly)
                const protocols = Object.keys(protocolGroups);
                protocols.forEach((protocol, i) => {
                    const offset = (i - (protocols.length - 1) / 2) * 5;
                    
                    link.filter(l => l.protocol === protocol && 
                        ((l.source.id === node1.id && l.target.id === node2.id) || 
                         (l.source.id === node2.id && l.target.id === node1.id)))
                        .classed("protocol-link", true)
                        .attr("stroke", protocolColors(protocol))
                        .attr("stroke-opacity", 0.8)
                        .attr("stroke-width", 3)
                        .each(function(d) {
                            const x1 = d.source.x;
                            const y1 = d.source.y;
                            const x2 = d.target.x;
                            const y2 = d.target.y;
                            const dx = x2 - x1;
                            const dy = y2 - y1;
                            const length = Math.sqrt(dx * dx + dy * dy);
                                
                            // Calculate perpendicular offset
                            const offsetX = -dy / length * offset;
                            const offsetY = dx / length * offset;
                                
                            d3.select(this)
                              .attr("x1", x1 + offsetX)
                              .attr("y1", y1 + offsetY)
                              .attr("x2", x2 + offsetX)
                              .attr("y2", y2 + offsetY);
                        });
                });
            }
            
            // Update protocol legend when showing connections
            function updateProtocolLegend(protocolGroups) {
                const protocolLegend = document.getElementById("protocolLegend");
                const protocolItems = document.getElementById("protocolItems");
                                
                // Clear previous items
                protocolItems.innerHTML = "";
                
                // If we have protocols to show
                if (Object.keys(protocolGroups).length > 0) {
                    protocolLegend.style.display = "block";
                    
                    // Create legend items for each protocol
                    Object.keys(protocolGroups).forEach(protocol => {
                        let linkSignals = 0
                        protocolGroups[protocol].forEach(link => {
                            linkSignals += link.value
                        })
                        const item = document.createElement("div");
                        item.className = "legend-item";
                        
                        const colorBox = document.createElement("div");
                        colorBox.className = "legend-color";
                        colorBox.style.backgroundColor = protocolColors(protocol);
                        
                        const label = document.createElement("span");
                        label.innerHTML = `${protocol} (${protocolGroups[protocol].length} connections)<br>${linkSignals} signals`;



                        item.appendChild(colorBox);
                        item.appendChild(label);
                        protocolItems.appendChild(item);
                    });
                } else {
                    protocolLegend.style.display = "none";
                }
            }
            
            // Reset graph visibility (show all nodes and links)
            function resetGraphVisibility() {
                node.style("opacity", 1);
                labels.style("opacity", 1);
                link.style("opacity", 0.6)
                    .classed("protocol-link", false)
                    .attr("stroke-width", d => Math.sqrt(d.value) + 1)
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);
                
                // Hide protocol legend
                document.getElementById("protocolLegend").style.display = "none";
            }
            
            // Create legend for node types
            createLegend();
            
            function createLegend() {
                const legendNodeContainer = document.getElementById('legendNodeContainer');
                legendNodeContainer.innerHTML = '';
                
                const nodeType = [
                    { type: "source", label: "Source" },
                    { type: "destination", label: "Destination" },
                    { type: "both", label: "Source & Dest" }
                ];

                nodeType.forEach(item => {
                    const legendNode = document.createElement('div');
                    legendNode.className = 'legend-item';
                    
                    const colorBox = document.createElement('div');
                    colorBox.className = 'legend-color';
                    colorBox.style.backgroundColor = nodeColors[item.type];
                    
                    const label = document.createElement('span');
                    label.textContent = item.label;
                    
                    legendNode.appendChild(colorBox);
                    legendNode.appendChild(label);
                    legendNodeContainer.appendChild(legendNode);
                });

                const legendLinkContainer = document.getElementById('legendLinkContainer');
                legendLinkContainer.innerHTML = '';

                processedData.stats.protocols.forEach(protocol => {
                    const legendLink = document.createElement('div');
                    legendLink.className = 'legend-item';
                    
                    const colorBox = document.createElement('div');
                    colorBox.className = 'legend-color';
                    colorBox.style.backgroundColor = protocolColors(protocol);
                    console.log(protocolColors(protocol))
                    
                    const label = document.createElement('span');
                    label.textContent = protocol;
                    
                    legendLink.appendChild(colorBox);
                    legendLink.appendChild(label);
                    legendLinkContainer.appendChild(legendLink);
                })
            }
            
            // Event listeners for controls
            document.getElementById('linkDistance').addEventListener('input', function() {
                linkDistance = parseInt(this.value);
                simulation.force("link").distance(linkDistance);
                simulation.alpha(0.3).restart();
            });
            
            document.getElementById('nodeCharge').addEventListener('input', function() {
                nodeCharge = parseInt(this.value);
                simulation.force("charge").strength(nodeCharge);
                simulation.alpha(0.3).restart();
            });
            
            document.getElementById('nodeSize').addEventListener('input', function() {
                baseNodeSize = parseInt(this.value);
                node.attr("r", d => calculateNodeSize(d));
            });
            
            // Toggle sidebar visibility
            document.getElementById('toggleSidebar').addEventListener('click', function() {
                const sidebar = document.getElementById('sidebar');
                const toggleBtn = document.getElementById('toggleSidebar');
                sidebar.classList.toggle('collapsed');
                
                if (sidebar.classList.contains('collapsed')) {
                    toggleBtn.innerHTML = '&gt;';
                    toggleBtn.classList.add('sidebar-hidden');
                } else {
                    toggleBtn.innerHTML = '&lt;';
                    toggleBtn.classList.remove('sidebar-hidden');
                }
                
                // Trigger resize to update the graph layout
                window.dispatchEvent(new Event('resize'));
            });
            
            document.getElementById('exportSVG').addEventListener('click', function() {
                const svgData = new XMLSerializer().serializeToString(svg.node());
                const svgBlob = new Blob([svgData], {type: "image/svg+xml;charset=utf-8"});
                const svgUrl = URL.createObjectURL(svgBlob);
                
                const downloadLink = document.createElement("a");
                downloadLink.href = svgUrl;
                downloadLink.download = "network_graph.svg";
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
            });
            
            // Protocol dropdown filter functionality
            document.getElementById('protocolFilter').addEventListener('change', function() {
                const selectedProtocol = this.value;
                if (!selectedProtocol) {
                    // If no protocol is selected, show all
                    return;
                }
                
                // Filter links by selected protocol
                const filteredLinks = processedData.links.filter(link => 
                    link.protocol === selectedProtocol
                );
                
                // Get all nodes involved in these links
                const nodeIds = new Set();
                filteredLinks.forEach(link => {
                    nodeIds.add(typeof link.source === 'object' ? link.source.id : link.source);
                    nodeIds.add(typeof link.target === 'object' ? link.target.id : link.target);
                });
                
                const filteredNodes = processedData.nodes.filter(node => nodeIds.has(node.id));
                
                // Update the graph with filtered data
                updateGraph(filteredNodes, filteredLinks);
                
                // Reset any previous selection
                clearNodeSelection();
                
                // Highlight matching protocol links
                link.filter(l => l.protocol === selectedProtocol)
                    .style("stroke-width", "4px")
                    .style("stroke-opacity", "1");
            });
            
            // IP search filter functionality
            document.getElementById('applyFilter').addEventListener('click', function() {
                applySearchFilter();
            });
            
            // Also apply filter when pressing Enter in the search field
            document.getElementById('searchFilter').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    applySearchFilter();
                }
            });
            
            document.getElementById('resetFilter').addEventListener('click', function() {
                document.getElementById('searchFilter').value = '';
                document.getElementById('protocolFilter').selectedIndex = 0;
                updateGraph(processedData.nodes, processedData.links);
                resetGraphVisibility();
                clearNodeSelection();
            });
            
            // Clear node selection button
            document.getElementById('clearSelection').addEventListener('click', function() {
                clearNodeSelection();
                resetGraphVisibility();
            });
            
            // Function to apply IP search filter
            function applySearchFilter() {
                const filterValue = document.getElementById('searchFilter').value.trim().toLowerCase();
                if (!filterValue) return;
                
                // Filter by IP address
                const filteredNodes = processedData.nodes.filter(node => 
                    node.id.toLowerCase().includes(filterValue)
                );
                
                // If we have any nodes, find connections to/from those nodes
                if (filteredNodes.length > 0) {
                    const nodeIds = new Set(filteredNodes.map(n => n.id));
                    
                    const connectedLinks = processedData.links.filter(link => 
                        nodeIds.has(typeof link.source === 'object' ? link.source.id : link.source) || 
                        nodeIds.has(typeof link.target === 'object' ? link.target.id : link.target)
                    );
                    
                    // Add nodes that are connected to our filtered nodes
                    connectedLinks.forEach(link => {
                        const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                        const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                        
                        if (!nodeIds.has(sourceId)) {
                            const sourceNode = processedData.nodes.find(n => n.id === sourceId);
                            if (sourceNode) {
                                filteredNodes.push(sourceNode);
                                nodeIds.add(sourceId);
                            }
                        }
                        
                        if (!nodeIds.has(targetId)) {
                            const targetNode = processedData.nodes.find(n => n.id === targetId);
                            if (targetNode) {
                                filteredNodes.push(targetNode);
                                nodeIds.add(targetId);
                            }
                        }
                    });
                    
                    // Update the graph with filtered data
                    updateGraph(filteredNodes, connectedLinks);
                    
                    // Reset any previous selection
                    clearNodeSelection();
                    
                    // Highlight matching nodes
                    const exactMatches = filteredNodes.filter(n => 
                        n.id.toLowerCase().includes(filterValue)
                    );
                    
                    if (exactMatches.length > 0) {
                        node.filter(n => exactMatches.some(m => m.id === n.id))
                            .style("stroke", "#ff6b6b")
                            .style("stroke-width", "3px");
                    }
                } else {
                    alert("No matches found for: " + filterValue);
                }
            }
            
            // Function to clear node selection
            function clearNodeSelection() {
                selectedNodes = [];
                node.classed("selected-node", false);
                document.getElementById("selectedCount").textContent = "0 nodes selected";
                document.getElementById("clearSelection").disabled = true;
                document.getElementById("protocolLegend").style.display = "none";
            }
            
            // Function to update the graph with new data
            function updateGraph(nodes, links) {
                // Update data references
                graphData = {
                    nodes: nodes,
                    links: links
                };
                
                // Remove all existing elements
                linkGroup.selectAll("line").remove();
                g.selectAll(".nodes").remove();
                g.selectAll("text").remove();
                
                // Create new links
                link = linkGroup.selectAll("line")
                    .data(links)
                    .enter()
                    .append("line")
                    .attr("stroke", d => protocolColors(d.protocol))
                    .attr("stroke-opacity", 0.6)
                    .attr("stroke-width", d => Math.sqrt(d.value) + 1);
                
                // Create new nodes
                node = g.append("g")
                    .attr("class", "nodes")
                    .selectAll("circle")
                    .data(nodes)
                    .enter()
                    .append("circle")
                    .attr("r", d => calculateNodeSize(d))
                    .attr("fill", d => getNodeColor(d))
                    .attr("stroke", "#fff")
                    .attr("stroke-width", 1.5)
                    .attr("cursor", "pointer")
                    .call(d3.drag()
                        .on("start", dragstarted)
                        .on("drag", dragged)
                        .on("end", dragended))
                    .on("mouseover", showNodeTooltip)
                    .on("mouseout", hideNodeTooltip)
                    .on("click", handleNodeClick);
                
                // Create new labels
                labels = g.append("g")
                    .selectAll("text")
                    .data(nodes)
                    .enter()
                    .append("text")
                    .text(d => d.id)
                    .attr("font-size", 10)
                    .attr("dx", 12)
                    .attr("dy", 4)
                    .style("pointer-events", "none")
                    .style("fill", "#333")
                    .style("font-weight", "bold")
                    .style("text-shadow", "0 0 3px white");
                
                // Update and restart the simulation
                simulation.nodes(nodes);
                simulation.force("link").links(links);
                simulation.alpha(1).restart();
            }
            
            // Handle window resize
            window.addEventListener('resize', function() {
                const newWidth = container.clientWidth;
                const newHeight = container.clientHeight;
                
                svg.attr("width", newWidth)
                   .attr("height", newHeight);
                
                simulation.force("center", d3.forceCenter(newWidth / 2, newHeight / 2))
                          .force("x", d3.forceX(newWidth / 2).strength(0.1))
                          .force("y", d3.forceY(newHeight / 2).strength(0.1))
                          .alpha(0.3)
                          .restart();
            });
        }

        // Initialize when document is loaded
        document.addEventListener('DOMContentLoaded', initializeGraph);
    </script>
</body>
</html>